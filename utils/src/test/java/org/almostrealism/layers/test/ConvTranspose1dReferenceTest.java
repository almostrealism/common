/*
 * Copyright 2025 Michael Murray
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.almostrealism.layers.test;

import org.almostrealism.collect.PackedCollection;
import org.almostrealism.io.Console;
import org.almostrealism.io.ConsoleFeatures;
import org.almostrealism.io.OutputFeatures;
import org.almostrealism.layers.LayerFeatures;
import org.almostrealism.model.Block;
import org.almostrealism.model.CompiledModel;
import org.almostrealism.model.Model;
import org.almostrealism.util.TestFeatures;
import org.junit.Test;

import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.file.Path;
import java.nio.file.Paths;

import static org.junit.Assert.*;

/**
 * Tests ConvTranspose1d against PyTorch reference outputs.
 *
 * <p>Reference data generated by generate_reference.py which creates test cases
 * with known sequential input values for easy verification.</p>
 *
 * <p>This test isolates ConvTranspose1d indexing issues by using simple inputs
 * that make manual verification straightforward.</p>
 */
public class ConvTranspose1dReferenceTest implements TestFeatures, LayerFeatures, ConsoleFeatures {

	private static final Path BASE_DIR = Paths.get("../ml/test_data/conv_transpose");
	private static final double TOLERANCE = 0.001;

	/**
	 * Loads a reference file (format: int32 count followed by float32 values).
	 */
	private float[] loadReference(String testCase, String filename) throws IOException {
		Path filepath = BASE_DIR.resolve(testCase).resolve(filename);

		if (!filepath.toFile().exists()) {
			throw new IOException("Reference file not found: " + filepath +
					"\nRun: python3 ../ml/test_data/conv_transpose/generate_reference.py");
		}

		try (DataInputStream dis = new DataInputStream(new FileInputStream(filepath.toFile()))) {
			byte[] countBytes = new byte[4];
			dis.readFully(countBytes);
			int count = ByteBuffer.wrap(countBytes).order(ByteOrder.LITTLE_ENDIAN).getInt();

			float[] values = new float[count];
			byte[] floatBytes = new byte[4];
			for (int i = 0; i < count; i++) {
				dis.readFully(floatBytes);
				values[i] = ByteBuffer.wrap(floatBytes).order(ByteOrder.LITTLE_ENDIAN).getFloat();
			}
			return values;
		}
	}

	private PackedCollection arrayToCollection(float[] data, int... dims) {
		PackedCollection c = new PackedCollection(dims);
		for (int i = 0; i < data.length; i++) {
			c.setMem(i, data[i]);
		}
		return c;
	}

	private void compareOutputs(String testName, PackedCollection actual, float[] expected) {
		int size = (int) actual.getMemLength();
		assertEquals(testName + " size mismatch", expected.length, size);

		log("\n" + testName + " comparison:");
		double maxDiff = 0;
		double sumDiff = 0;
		int failCount = 0;

		for (int i = 0; i < size; i++) {
			double actualVal = actual.toDouble(i);
			double expectedVal = expected[i];
			double diff = Math.abs(actualVal - expectedVal);

			maxDiff = Math.max(maxDiff, diff);
			sumDiff += diff;

			if (diff > TOLERANCE) {
				failCount++;
				if (failCount <= 10) {
					log(String.format("  [%d] actual=%.6f, expected=%.6f, diff=%.6f FAIL",
							i, actualVal, expectedVal, diff));
				}
			} else if (i < 5) {
				log(String.format("  [%d] actual=%.6f, expected=%.6f, diff=%.6f OK",
						i, actualVal, expectedVal, diff));
			}
		}

		double mae = sumDiff / size;
		log(String.format("\nMAE: %.6f, MaxDiff: %.6f, Failures: %d/%d",
				mae, maxDiff, failCount, size));

		assertEquals(testName + " has failures", 0, failCount);
	}

	/**
	 * Minimal test: 1 input channel, 1 output channel, stride=2, no padding.
	 * Input: [1, 2] -> Output: [0.01, 0.02, 0.02, 0.04]
	 */
	@Test
	public void testMinimal() throws IOException {
		if (!BASE_DIR.resolve("minimal").toFile().exists()) {
			log("Skipping - reference data not found. Run generate_reference.py");
			return;
		}

		Console.root().addListener(OutputFeatures.fileOutput(
				BASE_DIR.resolve("test_minimal.log").toString()));

		log("=== ConvTranspose1d Minimal Test ===");

		float[] input = loadReference("minimal", "input.bin");
		float[] weights = loadReference("minimal", "weights.bin");
		float[] bias = loadReference("minimal", "bias.bin");
		float[] expected = loadReference("minimal", "expected_output.bin");

		log("Input: " + java.util.Arrays.toString(input));
		log("Weights: " + java.util.Arrays.toString(weights));
		log("Bias: " + java.util.Arrays.toString(bias));
		log("Expected output: " + java.util.Arrays.toString(expected));

		// Parameters: batch=1, in_ch=1, out_ch=1, seq=2, kernel=2, stride=2, padding=0
		int batchSize = 1;
		int inChannels = 1;
		int outChannels = 1;
		int seqLength = 2;
		int kernel = 2;
		int stride = 2;
		int padding = 0;
		int outputPadding = 0;

		PackedCollection inputC = arrayToCollection(input, batchSize, inChannels, seqLength);
		PackedCollection weightsC = arrayToCollection(weights, inChannels, outChannels, kernel);
		PackedCollection biasC = arrayToCollection(bias, outChannels);

		Model model = new Model(shape(batchSize, inChannels, seqLength));
		model.add(convTranspose1d(batchSize, inChannels, outChannels, seqLength,
				kernel, stride, padding, outputPadding, weightsC, biasC));

		CompiledModel compiled = model.compile(false);
		PackedCollection output = compiled.forward(inputC);

		log("Output shape: " + output.getShape());
		compareOutputs("minimal", output, expected);

		log("\n=== Minimal Test PASSED ===");
	}

	/**
	 * Test with padding: kernel=4, stride=2, padding=1.
	 */
	@Test
	public void testWithPadding() throws IOException {
		if (!BASE_DIR.resolve("with_padding").toFile().exists()) {
			log("Skipping - reference data not found. Run generate_reference.py");
			return;
		}

		Console.root().addListener(OutputFeatures.fileOutput(
				BASE_DIR.resolve("test_with_padding.log").toString()));

		log("=== ConvTranspose1d With Padding Test ===");

		float[] input = loadReference("with_padding", "input.bin");
		float[] weights = loadReference("with_padding", "weights.bin");
		float[] bias = loadReference("with_padding", "bias.bin");
		float[] expected = loadReference("with_padding", "expected_output.bin");

		log("Input: " + java.util.Arrays.toString(input));
		log("Weights: " + java.util.Arrays.toString(weights));
		log("Expected output: " + java.util.Arrays.toString(expected));

		int batchSize = 1;
		int inChannels = 1;
		int outChannels = 1;
		int seqLength = 2;
		int kernel = 4;
		int stride = 2;
		int padding = 1;
		int outputPadding = 0;

		PackedCollection inputC = arrayToCollection(input, batchSize, inChannels, seqLength);
		PackedCollection weightsC = arrayToCollection(weights, inChannels, outChannels, kernel);
		PackedCollection biasC = arrayToCollection(bias, outChannels);

		Model model = new Model(shape(batchSize, inChannels, seqLength));
		model.add(convTranspose1d(batchSize, inChannels, outChannels, seqLength,
				kernel, stride, padding, outputPadding, weightsC, biasC));

		CompiledModel compiled = model.compile(false);
		PackedCollection output = compiled.forward(inputC);

		log("Output shape: " + output.getShape());
		compareOutputs("with_padding", output, expected);

		log("\n=== With Padding Test PASSED ===");
	}

	/**
	 * Multi-channel test: in_ch=2, out_ch=2, stride=2.
	 */
	@Test
	public void testMultichannelSmall() throws IOException {
		if (!BASE_DIR.resolve("multichannel_small").toFile().exists()) {
			log("Skipping - reference data not found. Run generate_reference.py");
			return;
		}

		Console.root().addListener(OutputFeatures.fileOutput(
				BASE_DIR.resolve("test_multichannel_small.log").toString()));

		log("=== ConvTranspose1d Multichannel Small Test ===");

		float[] input = loadReference("multichannel_small", "input.bin");
		float[] weights = loadReference("multichannel_small", "weights.bin");
		float[] bias = loadReference("multichannel_small", "bias.bin");
		float[] expected = loadReference("multichannel_small", "expected_output.bin");

		log("Input (first 10): " + java.util.Arrays.toString(java.util.Arrays.copyOf(input, Math.min(10, input.length))));
		log("Weights (first 10): " + java.util.Arrays.toString(java.util.Arrays.copyOf(weights, Math.min(10, weights.length))));

		int batchSize = 1;
		int inChannels = 2;
		int outChannels = 2;
		int seqLength = 2;
		int kernel = 2;
		int stride = 2;
		int padding = 0;
		int outputPadding = 0;

		PackedCollection inputC = arrayToCollection(input, batchSize, inChannels, seqLength);
		PackedCollection weightsC = arrayToCollection(weights, inChannels, outChannels, kernel);
		PackedCollection biasC = arrayToCollection(bias, outChannels);

		Model model = new Model(shape(batchSize, inChannels, seqLength));
		model.add(convTranspose1d(batchSize, inChannels, outChannels, seqLength,
				kernel, stride, padding, outputPadding, weightsC, biasC));

		CompiledModel compiled = model.compile(false);
		PackedCollection output = compiled.forward(inputC);

		log("Output shape: " + output.getShape());
		compareOutputs("multichannel_small", output, expected);

		log("\n=== Multichannel Small Test PASSED ===");
	}

	/**
	 * Oobleck-like test: stride=4, outputPadding=3.
	 * Similar to real Oobleck decoder but with tiny dimensions.
	 */
	@Test
	public void testOobleckLike() throws IOException {
		if (!BASE_DIR.resolve("oobleck_like").toFile().exists()) {
			log("Skipping - reference data not found. Run generate_reference.py");
			return;
		}

		Console.root().addListener(OutputFeatures.fileOutput(
				BASE_DIR.resolve("test_oobleck_like.log").toString()));

		log("=== ConvTranspose1d Oobleck-Like Test ===");

		float[] input = loadReference("oobleck_like", "input.bin");
		float[] weights = loadReference("oobleck_like", "weights.bin");
		float[] bias = loadReference("oobleck_like", "bias.bin");
		float[] expected = loadReference("oobleck_like", "expected_output.bin");

		log("Input: " + java.util.Arrays.toString(input));
		log("Expected output: " + java.util.Arrays.toString(expected));

		int batchSize = 1;
		int inChannels = 4;
		int outChannels = 2;
		int seqLength = 2;
		int kernel = 4;
		int stride = 4;
		int padding = 1;
		int outputPadding = 3;

		PackedCollection inputC = arrayToCollection(input, batchSize, inChannels, seqLength);
		PackedCollection weightsC = arrayToCollection(weights, inChannels, outChannels, kernel);
		PackedCollection biasC = arrayToCollection(bias, outChannels);

		Model model = new Model(shape(batchSize, inChannels, seqLength));
		model.add(convTranspose1d(batchSize, inChannels, outChannels, seqLength,
				kernel, stride, padding, outputPadding, weightsC, biasC));

		CompiledModel compiled = model.compile(false);
		PackedCollection output = compiled.forward(inputC);

		log("Output shape: " + output.getShape());
		compareOutputs("oobleck_like", output, expected);

		log("\n=== Oobleck-Like Test PASSED ===");
	}

	/**
	 * Stride=16 test: exactly like Oobleck decoder block 1 parameters but tiny channels.
	 * in_ch=2, out_ch=1, seq=2, kernel=16, stride=16, padding=7, outputPadding=15.
	 * Output length = (2-1)*16 - 2*7 + 16 + 15 = 16 - 14 + 31 = 33.
	 */
	@Test
	public void testStride16Tiny() throws IOException {
		if (!BASE_DIR.resolve("stride16_tiny").toFile().exists()) {
			log("Skipping - reference data not found. Run generate_reference.py");
			return;
		}

		Console.root().addListener(OutputFeatures.fileOutput(
				BASE_DIR.resolve("test_stride16_tiny.log").toString()));

		log("=== ConvTranspose1d Stride=16 Tiny Test ===");

		float[] input = loadReference("stride16_tiny", "input.bin");
		float[] weights = loadReference("stride16_tiny", "weights.bin");
		float[] bias = loadReference("stride16_tiny", "bias.bin");
		float[] expected = loadReference("stride16_tiny", "expected_output.bin");

		log("Input: " + java.util.Arrays.toString(input));
		log("Weights (first 16): " + java.util.Arrays.toString(java.util.Arrays.copyOf(weights, 16)));
		log("Expected output (first 16): " + java.util.Arrays.toString(java.util.Arrays.copyOf(expected, 16)));

		int batchSize = 1;
		int inChannels = 2;
		int outChannels = 1;
		int seqLength = 2;
		int kernel = 16;
		int stride = 16;
		int padding = 7;
		int outputPadding = 15;

		PackedCollection inputC = arrayToCollection(input, batchSize, inChannels, seqLength);
		PackedCollection weightsC = arrayToCollection(weights, inChannels, outChannels, kernel);
		PackedCollection biasC = arrayToCollection(bias, outChannels);

		Model model = new Model(shape(batchSize, inChannels, seqLength));
		model.add(convTranspose1d(batchSize, inChannels, outChannels, seqLength,
				kernel, stride, padding, outputPadding, weightsC, biasC));

		CompiledModel compiled = model.compile(false);
		PackedCollection output = compiled.forward(inputC);

		log("Output shape: " + output.getShape());
		log("Output values (first 16):");
		for (int i = 0; i < Math.min(16, output.getMemLength()); i++) {
			log(String.format("  [%d] = %.6f", i, output.toDouble(i)));
		}

		compareOutputs("stride16_tiny", output, expected);

		log("\n=== Stride=16 Tiny Test PASSED ===");
	}
}
