/*
 * Copyright 2025 Michael Murray
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.almostrealism.hardware.instructions;

import java.util.Objects;

/**
 * {@link ExecutionKey} implementation that identifies operations by their complete scope signature.
 *
 * <p>{@link ScopeSignatureExecutionKey} uses a comprehensive signature string that captures the full
 * operational semantics of a {@link io.almostrealism.scope.Scope}, including:</p>
 * <ul>
 *   <li>Operation type and name</li>
 *   <li>Argument types and shapes</li>
 *   <li>Precision (FP32, FP64, etc.)</li>
 *   <li>Traversal policy and dimensions</li>
 * </ul>
 *
 * <h2>Signature Format</h2>
 *
 * <p>Signatures are typically generated by {@link io.almostrealism.uml.Signature} implementations
 * and follow a structured format:</p>
 *
 * <pre>
 * OperationName_precision_dim1_dim2&amp;distinct=N;
 *
 * Examples:
 * - "Add_f64_3_2"              - Add operation, FP64, 3x2 shape
 * - "MatMul_f32_128_64&amp;distinct=2;" - MatMul, FP32, 128x64, 2 distinct arguments
 * </pre>
 *
 * <h2>Usage Example</h2>
 *
 * <pre>{@code
 * // Get signature from compiled scope
 * Scope<?> scope = computationCompiler.compile();
 * String signature = scope.getMetadata().getSignature();
 *
 * // Create execution key
 * ScopeSignatureExecutionKey key = new ScopeSignatureExecutionKey(signature);
 *
 * // Retrieve operation from cache
 * InstructionSetManager<ScopeSignatureExecutionKey> manager = ...;
 * Execution operation = manager.getOperator(key);
 * }</pre>
 *
 * <h2>Advantages Over DefaultExecutionKey</h2>
 *
 * <p>{@link ScopeSignatureExecutionKey} provides more precise caching than {@link DefaultExecutionKey}:</p>
 *
 * <pre>{@code
 * // These would be the same with DefaultExecutionKey("add", 3)
 * // but different with ScopeSignatureExecutionKey:
 *
 * "Add_f32_3_2"   // FP32 3x2 addition
 * "Add_f64_3_2"   // FP64 3x2 addition (different precision!)
 * "Add_f32_4_1"   // FP32 4x1 addition (different shape!)
 * }</pre>
 *
 * <h2>Cache Effectiveness</h2>
 *
 * <p>The signature-based approach ensures that only semantically identical operations share
 * cached compilations, preventing subtle bugs from type mismatches while maximizing reuse.</p>
 *
 * <h2>Equality Semantics</h2>
 *
 * <p>Two {@link ScopeSignatureExecutionKey} instances are equal if and only if their
 * signature strings are equal:</p>
 *
 * <pre>{@code
 * ScopeSignatureExecutionKey key1 = new ScopeSignatureExecutionKey("Add_f64_3_2");
 * ScopeSignatureExecutionKey key2 = new ScopeSignatureExecutionKey("Add_f64_3_2");
 * ScopeSignatureExecutionKey key3 = new ScopeSignatureExecutionKey("Add_f32_3_2");
 *
 * key1.equals(key2);  // true  - identical signatures
 * key1.equals(key3);  // false - different precision
 * }</pre>
 *
 * @see ExecutionKey
 * @see InstructionSetManager
 * @see io.almostrealism.uml.Signature
 */
public class ScopeSignatureExecutionKey implements ExecutionKey {
	private String signature;

	public ScopeSignatureExecutionKey(String signature) {
		this.signature = signature;
	}

	public String getSignature() { return signature; }

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (!(o instanceof ScopeSignatureExecutionKey that)) return false;
		return Objects.equals(getSignature(), that.getSignature());
	}

	@Override
	public int hashCode() {
		return Objects.hash(getSignature());
	}
}